\section{RMRS Comparison as Entailment}
\label{sec:entailment}

The definitions from Section~\ref{sec:rmrs} serve an important theoretical
purpose in that they provide a formal underpinning \rmrs's existing use
for partial semantic representations in implemented
systems.  Next to the peace of
mind that comes with the use of a formally understood formalism, a
clean definition can also provide a foundation for the development of
efficient algorithms; this has been shown in the past in the dominance
graph literature, most recently \newcite{KolRegTha08}.  We hope that
this paper can likewise provide a starting point for the development
of efficient solvers and inference mechanisms for \rmrs.

On the other hand, the above definition of \rmrs\ provides new
concepts which can help us phrase questions of practical grammar
engineering in well-defined formal terms.  For instance, one crucial
issue in developing a hybrid system that combines the outputs of deep
and shallow processors is to determine whether the \rmrs s produced by
the two systems are compatible.  Because we assume that the deep
grammar is more informative than that of the shallow processor, this
amounts to checking whether every piece of information in the shallow
representation is consistent with what the deep grammar said.  In
general, it isn't even obvious what ``consistency'' is supposed to
mean exactly, given that variables might be renamed, $\ARG$ roles
assigned in different ways, and structural relations underspecified.
But given the formal definition of \rmrs, we can now propose that an
\rmrs\ $\varphi'$ that was computed by a shallow processor is
consistent with an \rmrs\ $\varphi$ that was computed by a deep
grammar if $\varphi$ entails $\varphi'$ (i.e., $\varphi \models
\varphi'$).  If we could establish 
efficiently that $\varphi'$ is entailed by $\varphi$, this would tell
us that all models that satisfy $\varphi$ are also models of
$\varphi'$, i.e.\ the deep representation is formally more specific.

We cannot provide an efficient algorithm for testing entailment in
this paper.  However, we propose the following novel syntactic
characterisation of entailment.

\begin{definition}
  We call an \rmrs\ $\varphi'$ an \emph{extension} of an \rmrs\
  $\varphi$ iff \todo{fill this in -- don't have the def with me right
    now}.
\end{definition}

\begin{thm}\label{thm:big-one}
  Let $\varphi, \varphi'$ be two {\sc rmrs}s.  Then $\varphi \models
  \varphi'$ iff for every solved form $S$ of $\varphi$, there is a
  solved form $S'$ of $\varphi'$ such that $S$ is an extension of
  $S'$. 
\end{thm}
\begin{proof}[Proof (sketch)]
``$\Leftarrow$'' follows from
Props.~\ref{prop:solved-forms-are-satisfiable} and
\ref{prop:models-satisfy-solved-forms}.

``$\Rightarrow$'': The basic idea is to construct a solved form for
$\varphi'$ by choosing a solved form for $\varphi$ and removing all
atoms using variables that don't occur in $\varphi'$.  The hard part
is the proof that the result is a solved form of $\varphi'$; this step
involves proving that if $\varphi \models \varphi'$, then all {\sc ep}s in
$\varphi'$ also occur in $\varphi$.  
\end{proof}

This characterisation does not by itself provide an efficient test for
entailment because the number of solved forms of $\varphi$ and
$\varphi'$ may be exponential, and thus it is infeasible to compute
them all and then test for extensions.  Nevertheless, we hope that the
theorem provides a first step towards an improved understanding of
entailment that will lead to such an efficient algorithm in the
future.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "rmrs-08"
%%% End: 

\section{Generating referring expressions} \label{sec:gre}

In computational linguistics, the generating referring expression problem (the GRE
problem) can be intuitively presented as follows: given some information about
a group of individuals (e.g., grounded facts about individuals in an ongoing dialogue),
and a grammar, found a grammatically correct expression (usually a noun phrase) that uniquely identify a given individual.

By taking a logic perspective, we can recast the GRE problem as an inference problem.
We can think that the information about the group of individuals is provided in the form
of a model $\gM$ of a given logical language $\gL$.  Now, the inference problem
associated with the GRE problem will be to find a formula in $\gL$ such that it
exaclty identifies a given individual $i$.  Formally, if $|\cdot|^\gM$ is the interpretation
function for $\gL$ which for each formula in $\gL$ and for each model $\gM$ returns
the set of elements in $\gM$ for which the formula $\varphi$ holds, then we can define:
\medskip

\noindent
{\small
\begin{center}
\begin{tabular}{ll} \hline
\multicolumn{2}{l}{
\textsc{$\gL$-GRE Problem}}\\ \hline
\ \ Input: & A model $\gM$ and an individual $i$ in the\\
& \hspace*{0.5cm} domain of $\gM$.\\
\ \ Output: & A formula $\varphi \in \gL$ such that $|\varphi|^\gM = \{i\}$\\
& \hspace*{0.5cm} (if such a formula exists).\\ \hline
\end{tabular}
\end{center}}
\medskip

As it can be seen from the definition, the problem depends on which particular
logical language $\gL$ we are interested in, and (as the original GRE problem)
it might terminate with failure.  Depending on \emph{a)} the model $\gM$,
\emph{b)} the chosen individual $i$
and \emph{c} the expressive power of $\gL$, it can be the case that there is no formula of
$\gL$ that uniquely identifies $i$ in $\gM$.

Consider the following example.  We have three individuals related as indicated in
Figure~\ref{fig-car1}.
\begin{figure}
\begin{center}
\includegraphics[scale=.8]{pic.pdf}
\end{center}
\caption{Distinguishable/indistinguishable points.}\label{fig-car1}
\end{figure}
%
The individuals $i$ and $i'$ can easily be distinguished in first-order logic:
the formula $R(x,x)$ is true of $i$ and false in $i'$. The corresponding
referring expression for $i$ would be ``an individual relating to itself''.
But if we can only use propositional and relational information (equivalently, our grammar does not contain the word ``itself'') then $i$ and $i'$ are indistinguishable. Both
are ``individuals which are related to individuals which are related to individuals\ldots''

We can connect description logics to the problem of generating
referring expressions via the concept of \emph{bisimulation classes}.
A bisimulation class is a maximal subset $C$ of the domain such that
all members of $C$ are pairwise bisimilar.  For the finite models we
deal with in GRE, this amounts to saying that there are certain
concepts that are satisfied by all individuals in $C$ and no
individuals that are not in $C$ (by Theorems~\ref{bisim} and
\ref{bisim2}).  If we represent referring expressions as DL concepts,
this means that there exists a unique referring expression for some
individual $a$ iff $a$ is alone in its bisimulation class; and if it
is, we can use one of the concepts that are characteristic for $C$ as
the referring expression.

Representing referring expressions as DL concepts is a very natural
perspective.  The purely conjunctive bag of propositional symbols that
e.g.\ \newcite{Dale1995} compute is clearly a conjunction in
description logic.  Relational expressions as in
\newcite{dale91:_gener_refer_expres_invol_relat} or
\newcite{Krahmer2003} are simply concepts of \el; for instance, ``the
book on the table'' corresponds to the concept $\mathsf{book} \sqcap
\exists \mathsf{on}. \mathsf{table}$.  And other propositional
connectives, such as disjunction and negation
\cite{deemter01:_gener_refer_expres}, can clearly be represented in
\alc\ as well.

All this means that we can reduce the problem of computing a unique RE
to the problem of computing the bisimulation classes of a model.  We
will now present two algorithms -- one for \alc\ and one for \el\ --
for doing this.  In fact, each of these algorithms computes all
bisimulation classes of a model at once, effectively computing a RE
for every single individual in the domain simultaneously.


\subsection{Bisimulation classes for \alc}


\subsection{Bisimulation classes for \el}

The algorithm we just presented is driven by case distinctions between
concepts $\varphi$ and $\neg \varphi$, and thus adds large amounts of
negations to the characteristic concepts.  This can be inconvenient
in NLG, because such concepts may be expressible only by rather clumsy
natural-language expressions. \todo{example?}  We will therefore
introduce a new algorithm which is limited to computing
(negation-free) concepts of \el.  

As before, the algorithm maintains a set $\C = \{C_1,\ldots,C_n\}$ of
concepts (this time of \el) such that $\interp{C_1} \cup \ldots \cup
\interp{C_n} = \Delta$, and which it refines iteratively.  However,
where the \alc\ algorithm maintains the invariant that
$\interp{C_1},\ldots,\interp{C_n}$ is a partition of $\Delta$, we
weaken this invariant to the requirement that there are no $m \geq 2$
pairwise different indices $1 \leq i_1,\ldots,i_m \leq n$ such that
$\interp{C_{i_1}} = \interp{C_{i_2}} \cup \ldots \cup
\interp{C_{i_m}}$.  We call the concept $C_{i_1}$ \emph{subsumed} if
such a decomposition exists.

% \begin{algorithm}[t]
% \dontprintsemicolon
% \caption{\el\ bisimulation classes}
% \label{algo:bisim-el}
% \KwIn{A model $\gM = (\Delta^\gM, |\cdot|^\gM)$}
% \KwOut{A set \RE of pairs $(\varphi,|\varphi|^\gM)$ such that
% $\{S \mid (\varphi,S) \in \RE\}$ is the set of $\el$-bisimulation
% classes of $\gM$.}
% \RE $\leftarrow \{(\top,\Delta^\gM)\}$ \;
% \For{$p \in \prop$}{
%   add$_\el$(p, \RE) \;
% }
% \While{for some $(\varphi,S) \in \RE$, $|S| > 1$}{
%   \For{$(\varphi,S) \in$ \RE, $R \in \rel$}{
%     add$_\el$($\exists R.\varphi$, \RE) \;
%   }
%   \If{made no changes to $\RE$}{
%     exit\;
%   }
% }
% \end{algorithm}




\begin{algorithm}[t]
\dontprintsemicolon
\caption{}
\label{algo:bisim-alc}
\KwIn{A model $\gM = (\Delta^\gM, |\cdot|^\gM)$}
\KwOut{A set \RE of formulas  such that
$\{|\varphi|^\gM \in \RE\}$ is the set of $\mathcal{L}$-bisimulation
classes of $\gM$.}

$\RE \leftarrow \{\top\}$

\For{$p \in \prop$}{
      add$_\mathcal{L}(p,\RE)$
   }

\While{for some $\varphi \in \RE, |\varphi|^\gM>1$}{
   \For{$\varphi \in \RE, R \in \rel$}{
         add$_\mathcal{L}(\exists R.\varphi,\RE)$
   }
   \If{made no changes to \RE}{
      exit
      }
}
 
\end{algorithm}

\begin{algorithm}
\caption{add$_\alc(\varphi,\RE)$}
\For{$\psi \in \RE$ with $|\psi|^\gM > 1$}{
   \If{$|\psi \sqcap \varphi|^\gM \not = \emptyset$ and
       $|\psi \sqcap \neg \varphi|^\gM \not = \emptyset$}{
         add $\psi \sqcap \varphi$ and
               $\psi \sqcap \neg \varphi$ to \RE \;
         remove $\psi$ from \RE \;
      }
   }
\end{algorithm}


\begin{algorithm}[t]
\dontprintsemicolon
\caption{add$_\el$($\varphi$, $\RE$)}
\label{algo:bisim-add-el}
\For{$\psi \in \RE$ with $|\psi|^\gM > 1$}{
  \If{$\psi \sqcap \varphi$ is not subsumed in $\RE$ {\bf and}
    $|\psi \sqcap \varphi|^\gM \neq \emptyset$ {\bf and}
    $|\psi \sqcap \varphi|^\gM \neq |\psi|^\gM$}{
    add $\psi \sqcap \varphi$ to $\RE$ \;
    remove subsumed concepts from $\RE$\;
  }
}
\end{algorithm}

Algorithms~\ref{algo:bisim-el} and \ref{algo:bisim-add-el} compute
the \el\ bisimulation classes for a given model.
Algorithm~\ref{algo:bisim-el} iterates over all propositional and
relational symbols of the signature to construct new concepts until
either all concepts in $\C$ are singleton (i.e., there is only one
individual that satisfies them), or no progress has been made in the
previous iteration.  In each iteration, it calls the procedure
add$_\el$($C$, $\C$), which intersects $C$ with all current concepts
that are not already singleton, adds the result to $\C$ and then
removes all concepts in $\C$ that have become subsumed.  Removal of
subsumed concepts can be implemented efficiently by arranging the
concepts in $\C$ in a a graph that connects two concepts with an edge
if one is a maximal proper subset of the other.

\begin{figure}
  \centering
  \includegraphics[width=5cm]{pic-dale-haddock}
  \caption{The Dale and Haddock scenario.}
  \label{fig:dale-haddock}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{pic-el-vs-alc}
  \caption{Illustrating the difference between \el\ and \alc.}
  \label{fig:el-vs-alc}
\end{figure}

Let's see what this algorithm does on the example shown in
Fig.~\ref{fig:dale-haddock}, which is taken from
\newcite{dale91:_gener_refer_expres_invol_relat}.  In the first loop,
the algorithm will add new concepts $\mathsf{floor}$, $\mathsf{bowl}$,
$\mathsf{cup}$, and $\mathsf{table}$; because adding these concepts
makes $\top$ subsumed, $\C$ will consist of these four concepts after
the loop.  Not all of these concepts are singleton; for instance,
$\interp{\mathsf{cup}}$ contains two individuals.  So we iterate over
the relations to make the concepts more precise.  After the first
iteration over the relations, we have $\C = \{ \mathsf{floor},
\mathsf{bowl} \sqcap \exists \mathsf{on}.\mathsf{floor}, \mathsf{bowl}
\sqcap \exists \mathsf{on}.\mathsf{table}, \mathsf{cup},
\mathsf{table} \}$. Notice that $\mathsf{bowl}$ has become subsumed,
but we haven't distinguished the cups and tables further, but we can
use the distinction between the bowls to distinguish the cups in the
second iteration.  The result of this is $\C = \{ \mathsf{floor},
\mathsf{bowl} \sqcap \exists \mathsf{on}.\mathsf{floor}, \mathsf{bowl}
\sqcap \exists \mathsf{on}.\mathsf{table}, \mathsf{cup} \sqcap \exists
\mathsf{in}. (\mathsf{bowl} \sqcap \exists
\mathsf{on}.\mathsf{floor}), \mathsf{cup} \sqcap \exists
\mathsf{in}. (\mathsf{bowl} \sqcap \exists
\mathsf{on}.\mathsf{table}), \mathsf{table} \}$.  At this point, all
concepts except for $\mathsf{table}$ are singleton, and further
iterations don't allow us to refine $\mathsf{table}$; so the algorithm
terminates.  Each of the singleton bisimulation classes is represented
by a characteristic concept; for instance, $\C$ tells us that
$\mathsf{cup} \sqcap \exists \mathsf{in}. (\mathsf{bowl} \sqcap
\exists \mathsf{on}.\mathsf{table})$ is only satisfied by $c_2$, so we
may refer to $c_2$ as ``the cup in the bowl on the table''.

Compared to the \alc\ algorithm, the \el\ algorithm will generally
compute larger bisimulation classes, and compute singleton
bisimulation classes less frequently, because the concepts it can
build can ``see'' fewer differences between individuals.  For example,
in the model shown in Fig.~\ref{fig:el-vs-alc}, the \alc\ algorithm
will compute the concepts $\{\neg \exists R. (\neg P \sqcap \neg Q),
Q, \exists R. (\neg P \sqcap \neg Q), \neg P \sqcap \neg Q\}$ (each of
which is singleton), but $a$ and $c$ are \el-bisimilar in this model,
and the only \el-concept that is true in $d$ is $\top$, so the \el\
algorithm can only compute the concepts $\{\top, P, P \sqcap Q\}$.
Furthermore, because the \el\ algorithm maintains a weaker invariant
for the classes, it may consider more of these classes simultaneously.
Prima facie, this means that it has worst-case exponential runtime,
given that the whole domain has an exponential number of subsets.
However, it is possible that a more careful analysis of the
combinatorics of the considered subsets reveal that the algorithm is
actually polynomial; it certainly behaves polynomially in our
evaluations (see below).


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "dl-gre-08"
%%% End: 
